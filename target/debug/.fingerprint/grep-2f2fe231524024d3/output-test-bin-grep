{"$message_type":"diagnostic","message":"unused import: `std::str::FromStr`","code":{"code":"unused_imports","explanation":null},"level":"warning","spans":[{"file_name":"src/nfa.rs","byte_start":96,"byte_end":113,"line_start":4,"line_end":4,"column_start":5,"column_end":22,"is_primary":true,"text":[{"text":"use std::str::FromStr;","highlight_start":5,"highlight_end":22}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"`#[warn(unused_imports)]` on by default","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"remove the whole `use` item","code":null,"level":"help","spans":[{"file_name":"src/nfa.rs","byte_start":92,"byte_end":114,"line_start":4,"line_end":4,"column_start":1,"column_end":23,"is_primary":true,"text":[{"text":"use std::str::FromStr;","highlight_start":1,"highlight_end":23}],"label":null,"suggested_replacement":"","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[33mwarning\u001b[0m\u001b[0m\u001b[1m: unused import: `std::str::FromStr`\u001b[0m\n\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/nfa.rs:4:5\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m4\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0muse std::str::FromStr;\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[33m^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: `#[warn(unused_imports)]` on by default\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"unused import: `crate::earley_parse::CFG`","code":{"code":"unused_imports","explanation":null},"level":"warning","spans":[{"file_name":"src/nfa.rs","byte_start":119,"byte_end":143,"line_start":5,"line_end":5,"column_start":5,"column_end":29,"is_primary":true,"text":[{"text":"use crate::earley_parse::CFG;","highlight_start":5,"highlight_end":29}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"remove the whole `use` item","code":null,"level":"help","spans":[{"file_name":"src/nfa.rs","byte_start":115,"byte_end":144,"line_start":5,"line_end":5,"column_start":1,"column_end":30,"is_primary":true,"text":[{"text":"use crate::earley_parse::CFG;","highlight_start":1,"highlight_end":30}],"label":null,"suggested_replacement":"","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[33mwarning\u001b[0m\u001b[0m\u001b[1m: unused import: `crate::earley_parse::CFG`\u001b[0m\n\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/nfa.rs:5:5\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m5\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0muse crate::earley_parse::CFG;\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[33m^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"unused import: `std::iter::Filter`","code":{"code":"unused_imports","explanation":null},"level":"warning","spans":[{"file_name":"src/nfa.rs","byte_start":231,"byte_end":248,"line_start":8,"line_end":8,"column_start":5,"column_end":22,"is_primary":true,"text":[{"text":"use std::iter::Filter;","highlight_start":5,"highlight_end":22}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"remove the whole `use` item","code":null,"level":"help","spans":[{"file_name":"src/nfa.rs","byte_start":227,"byte_end":249,"line_start":8,"line_end":8,"column_start":1,"column_end":23,"is_primary":true,"text":[{"text":"use std::iter::Filter;","highlight_start":1,"highlight_end":23}],"label":null,"suggested_replacement":"","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[33mwarning\u001b[0m\u001b[0m\u001b[1m: unused import: `std::iter::Filter`\u001b[0m\n\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/nfa.rs:8:5\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m8\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0muse std::iter::Filter;\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[33m^^^^^^^^^^^^^^^^^\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"unused import: `std::cmp::max`","code":{"code":"unused_imports","explanation":null},"level":"warning","spans":[{"file_name":"src/helper.rs","byte_start":4,"byte_end":17,"line_start":1,"line_end":1,"column_start":5,"column_end":18,"is_primary":true,"text":[{"text":"use std::cmp::max;","highlight_start":5,"highlight_end":18}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"remove the whole `use` item","code":null,"level":"help","spans":[{"file_name":"src/helper.rs","byte_start":0,"byte_end":18,"line_start":1,"line_end":1,"column_start":1,"column_end":19,"is_primary":true,"text":[{"text":"use std::cmp::max;","highlight_start":1,"highlight_end":19}],"label":null,"suggested_replacement":"","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[33mwarning\u001b[0m\u001b[0m\u001b[1m: unused import: `std::cmp::max`\u001b[0m\n\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/helper.rs:1:5\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0muse std::cmp::max;\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[33m^^^^^^^^^^^^^\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"unused import: `crate::earley_parse::CFG`","code":{"code":"unused_imports","explanation":null},"level":"warning","spans":[{"file_name":"src/helper.rs","byte_start":117,"byte_end":141,"line_start":7,"line_end":7,"column_start":5,"column_end":29,"is_primary":true,"text":[{"text":"use crate::earley_parse::CFG;","highlight_start":5,"highlight_end":29}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"remove the whole `use` item","code":null,"level":"help","spans":[{"file_name":"src/helper.rs","byte_start":113,"byte_end":142,"line_start":7,"line_end":7,"column_start":1,"column_end":30,"is_primary":true,"text":[{"text":"use crate::earley_parse::CFG;","highlight_start":1,"highlight_end":30}],"label":null,"suggested_replacement":"","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[33mwarning\u001b[0m\u001b[0m\u001b[1m: unused import: `crate::earley_parse::CFG`\u001b[0m\n\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/helper.rs:7:5\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m7\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0muse crate::earley_parse::CFG;\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[33m^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"unused import: `crate::nfa::NFA`","code":{"code":"unused_imports","explanation":null},"level":"warning","spans":[{"file_name":"src/main.rs","byte_start":74,"byte_end":89,"line_start":7,"line_end":7,"column_start":5,"column_end":20,"is_primary":true,"text":[{"text":"use crate::nfa::NFA;","highlight_start":5,"highlight_end":20}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"remove the whole `use` item","code":null,"level":"help","spans":[{"file_name":"src/main.rs","byte_start":70,"byte_end":90,"line_start":7,"line_end":7,"column_start":1,"column_end":21,"is_primary":true,"text":[{"text":"use crate::nfa::NFA;","highlight_start":1,"highlight_end":21}],"label":null,"suggested_replacement":"","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[33mwarning\u001b[0m\u001b[0m\u001b[1m: unused import: `crate::nfa::NFA`\u001b[0m\n\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/main.rs:7:5\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m7\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0muse crate::nfa::NFA;\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[33m^^^^^^^^^^^^^^^\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"unused import: `crate::earley_parse::CFG`","code":{"code":"unused_imports","explanation":null},"level":"warning","spans":[{"file_name":"src/main.rs","byte_start":95,"byte_end":119,"line_start":8,"line_end":8,"column_start":5,"column_end":29,"is_primary":true,"text":[{"text":"use crate::earley_parse::CFG;","highlight_start":5,"highlight_end":29}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"remove the whole `use` item","code":null,"level":"help","spans":[{"file_name":"src/main.rs","byte_start":91,"byte_end":120,"line_start":8,"line_end":8,"column_start":1,"column_end":30,"is_primary":true,"text":[{"text":"use crate::earley_parse::CFG;","highlight_start":1,"highlight_end":30}],"label":null,"suggested_replacement":"","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[33mwarning\u001b[0m\u001b[0m\u001b[1m: unused import: `crate::earley_parse::CFG`\u001b[0m\n\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/main.rs:8:5\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m8\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0muse crate::earley_parse::CFG;\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[33m^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"unused import: `std::collections::HashSet`","code":{"code":"unused_imports","explanation":null},"level":"warning","spans":[{"file_name":"src/main.rs","byte_start":288,"byte_end":313,"line_start":11,"line_end":11,"column_start":5,"column_end":30,"is_primary":true,"text":[{"text":"use std::collections::HashSet;","highlight_start":5,"highlight_end":30}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"remove the whole `use` item","code":null,"level":"help","spans":[{"file_name":"src/main.rs","byte_start":284,"byte_end":314,"line_start":11,"line_end":11,"column_start":1,"column_end":31,"is_primary":true,"text":[{"text":"use std::collections::HashSet;","highlight_start":1,"highlight_end":31}],"label":null,"suggested_replacement":"","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[33mwarning\u001b[0m\u001b[0m\u001b[1m: unused import: `std::collections::HashSet`\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/main.rs:11:5\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m11\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0muse std::collections::HashSet;\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[33m^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"unused import: `std::error::Error`","code":{"code":"unused_imports","explanation":null},"level":"warning","spans":[{"file_name":"src/main.rs","byte_start":333,"byte_end":350,"line_start":13,"line_end":13,"column_start":5,"column_end":22,"is_primary":true,"text":[{"text":"use std::error::Error;","highlight_start":5,"highlight_end":22}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"remove the whole `use` item","code":null,"level":"help","spans":[{"file_name":"src/main.rs","byte_start":329,"byte_end":351,"line_start":13,"line_end":13,"column_start":1,"column_end":23,"is_primary":true,"text":[{"text":"use std::error::Error;","highlight_start":1,"highlight_end":23}],"label":null,"suggested_replacement":"","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[33mwarning\u001b[0m\u001b[0m\u001b[1m: unused import: `std::error::Error`\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/main.rs:13:5\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m13\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0muse std::error::Error;\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[33m^^^^^^^^^^^^^^^^^\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"unused import: `std::fmt::Result`","code":{"code":"unused_imports","explanation":null},"level":"warning","spans":[{"file_name":"src/main.rs","byte_start":356,"byte_end":372,"line_start":14,"line_end":14,"column_start":5,"column_end":21,"is_primary":true,"text":[{"text":"use std::fmt::Result;","highlight_start":5,"highlight_end":21}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"remove the whole `use` item","code":null,"level":"help","spans":[{"file_name":"src/main.rs","byte_start":352,"byte_end":373,"line_start":14,"line_end":14,"column_start":1,"column_end":22,"is_primary":true,"text":[{"text":"use std::fmt::Result;","highlight_start":1,"highlight_end":22}],"label":null,"suggested_replacement":"","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[33mwarning\u001b[0m\u001b[0m\u001b[1m: unused import: `std::fmt::Result`\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/main.rs:14:5\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m14\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0muse std::fmt::Result;\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[33m^^^^^^^^^^^^^^^^\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"unused import: `std::hash::Hash`","code":{"code":"unused_imports","explanation":null},"level":"warning","spans":[{"file_name":"src/main.rs","byte_start":397,"byte_end":412,"line_start":16,"line_end":16,"column_start":5,"column_end":20,"is_primary":true,"text":[{"text":"use std::hash::Hash;","highlight_start":5,"highlight_end":20}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"remove the whole `use` item","code":null,"level":"help","spans":[{"file_name":"src/main.rs","byte_start":393,"byte_end":413,"line_start":16,"line_end":16,"column_start":1,"column_end":21,"is_primary":true,"text":[{"text":"use std::hash::Hash;","highlight_start":1,"highlight_end":21}],"label":null,"suggested_replacement":"","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[33mwarning\u001b[0m\u001b[0m\u001b[1m: unused import: `std::hash::Hash`\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/main.rs:16:5\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m16\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0muse std::hash::Hash;\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[33m^^^^^^^^^^^^^^^\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"unused import: `self`","code":{"code":"unused_imports","explanation":null},"level":"warning","spans":[{"file_name":"src/main.rs","byte_start":428,"byte_end":432,"line_start":17,"line_end":17,"column_start":15,"column_end":19,"is_primary":true,"text":[{"text":"use std::io::{self, BufReader, BufRead};","highlight_start":15,"highlight_end":19}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"remove the unused import","code":null,"level":"help","spans":[{"file_name":"src/main.rs","byte_start":428,"byte_end":434,"line_start":17,"line_end":17,"column_start":15,"column_end":21,"is_primary":true,"text":[{"text":"use std::io::{self, BufReader, BufRead};","highlight_start":15,"highlight_end":21}],"label":null,"suggested_replacement":"","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[33mwarning\u001b[0m\u001b[0m\u001b[1m: unused import: `self`\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/main.rs:17:15\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m17\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0muse std::io::{self, BufReader, BufRead};\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m              \u001b[0m\u001b[0m\u001b[1m\u001b[33m^^^^\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"this function takes 4 arguments but 2 arguments were supplied","code":{"code":"E0061","explanation":"An invalid number of arguments was passed when calling a function.\n\nErroneous code example:\n\n```compile_fail,E0061\nfn f(u: i32) {}\n\nf(); // error!\n```\n\nThe number of arguments passed to a function must match the number of arguments\nspecified in the function signature.\n\nFor example, a function like:\n\n```\nfn f(a: u16, b: &str) {}\n```\n\nMust always be called with exactly two arguments, e.g., `f(2, \"test\")`.\n\nNote that Rust does not have a notion of optional function arguments or\nvariadic functions (except for its C-FFI).\n"},"level":"error","spans":[{"file_name":"src/helper.rs","byte_start":7327,"byte_end":7340,"line_start":258,"line_end":258,"column_start":54,"column_end":67,"is_primary":false,"text":[{"text":"        let output_strs = check_str_prefix_extraction(regex, line);","highlight_start":54,"highlight_end":67}],"label":"two arguments of type `&str` and `Vec<usize>` are missing","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/helper.rs","byte_start":7300,"byte_end":7327,"line_start":258,"line_end":258,"column_start":27,"column_end":54,"is_primary":true,"text":[{"text":"        let output_strs = check_str_prefix_extraction(regex, line);","highlight_start":27,"highlight_end":54}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"function defined here","code":null,"level":"note","spans":[{"file_name":"src/helper.rs","byte_start":4850,"byte_end":4860,"line_start":184,"line_end":184,"column_start":36,"column_end":46,"is_primary":false,"text":[{"text":"pub fn check_str_prefix_extraction(rest: &str, prefix: &str, line: &str, start_positions: Vec<usize>) -> HashMap<usize, String> {","highlight_start":36,"highlight_end":46}],"label":"","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/helper.rs","byte_start":4862,"byte_end":4874,"line_start":184,"line_end":184,"column_start":48,"column_end":60,"is_primary":false,"text":[{"text":"pub fn check_str_prefix_extraction(rest: &str, prefix: &str, line: &str, start_positions: Vec<usize>) -> HashMap<usize, String> {","highlight_start":48,"highlight_end":60}],"label":"","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/helper.rs","byte_start":4876,"byte_end":4886,"line_start":184,"line_end":184,"column_start":62,"column_end":72,"is_primary":false,"text":[{"text":"pub fn check_str_prefix_extraction(rest: &str, prefix: &str, line: &str, start_positions: Vec<usize>) -> HashMap<usize, String> {","highlight_start":62,"highlight_end":72}],"label":"","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/helper.rs","byte_start":4888,"byte_end":4915,"line_start":184,"line_end":184,"column_start":74,"column_end":101,"is_primary":false,"text":[{"text":"pub fn check_str_prefix_extraction(rest: &str, prefix: &str, line: &str, start_positions: Vec<usize>) -> HashMap<usize, String> {","highlight_start":74,"highlight_end":101}],"label":"","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/helper.rs","byte_start":4822,"byte_end":4849,"line_start":184,"line_end":184,"column_start":8,"column_end":35,"is_primary":true,"text":[{"text":"pub fn check_str_prefix_extraction(rest: &str, prefix: &str, line: &str, start_positions: Vec<usize>) -> HashMap<usize, String> {","highlight_start":8,"highlight_end":35}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"provide the arguments","code":null,"level":"help","spans":[{"file_name":"src/helper.rs","byte_start":7327,"byte_end":7340,"line_start":258,"line_end":258,"column_start":54,"column_end":67,"is_primary":true,"text":[{"text":"        let output_strs = check_str_prefix_extraction(regex, line);","highlight_start":54,"highlight_end":67}],"label":null,"suggested_replacement":"(regex, line, /* &str */, /* Vec<usize> */)","suggestion_applicability":"HasPlaceholders","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0061]\u001b[0m\u001b[0m\u001b[1m: this function takes 4 arguments but 2 arguments were supplied\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/helper.rs:258:27\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m258\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m        let output_strs = check_str_prefix_extraction(regex, line);\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                          \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m-------------\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12mtwo arguments of type `&str` and `Vec<usize>` are missing\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;10mnote\u001b[0m\u001b[0m: function defined here\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/helper.rs:184:8\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m184\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0mpub fn check_str_prefix_extraction(rest: &str, prefix: &str, line: &str, start_positions: Vec<usize>) -> HashMap<usize, String> {\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m       \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m----------\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m------------\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m----------\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m---------------------------\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14mhelp\u001b[0m\u001b[0m: provide the arguments\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m258\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m        let output_strs = check_str_prefix_extraction\u001b[0m\u001b[0m\u001b[38;5;10m(regex, line, /* &str */, /* Vec<usize> */)\u001b[0m\u001b[0m;\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                                                      \u001b[0m\u001b[0m\u001b[38;5;10m~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"this function takes 4 arguments but 2 arguments were supplied","code":{"code":"E0061","explanation":"An invalid number of arguments was passed when calling a function.\n\nErroneous code example:\n\n```compile_fail,E0061\nfn f(u: i32) {}\n\nf(); // error!\n```\n\nThe number of arguments passed to a function must match the number of arguments\nspecified in the function signature.\n\nFor example, a function like:\n\n```\nfn f(a: u16, b: &str) {}\n```\n\nMust always be called with exactly two arguments, e.g., `f(2, \"test\")`.\n\nNote that Rust does not have a notion of optional function arguments or\nvariadic functions (except for its C-FFI).\n"},"level":"error","spans":[{"file_name":"src/helper.rs","byte_start":11056,"byte_end":11069,"line_start":353,"line_end":353,"column_start":54,"column_end":67,"is_primary":false,"text":[{"text":"        let output_strs = check_str_prefix_extraction(regex, line);","highlight_start":54,"highlight_end":67}],"label":"two arguments of type `&str` and `Vec<usize>` are missing","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/helper.rs","byte_start":11029,"byte_end":11056,"line_start":353,"line_end":353,"column_start":27,"column_end":54,"is_primary":true,"text":[{"text":"        let output_strs = check_str_prefix_extraction(regex, line);","highlight_start":27,"highlight_end":54}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"function defined here","code":null,"level":"note","spans":[{"file_name":"src/helper.rs","byte_start":4850,"byte_end":4860,"line_start":184,"line_end":184,"column_start":36,"column_end":46,"is_primary":false,"text":[{"text":"pub fn check_str_prefix_extraction(rest: &str, prefix: &str, line: &str, start_positions: Vec<usize>) -> HashMap<usize, String> {","highlight_start":36,"highlight_end":46}],"label":"","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/helper.rs","byte_start":4862,"byte_end":4874,"line_start":184,"line_end":184,"column_start":48,"column_end":60,"is_primary":false,"text":[{"text":"pub fn check_str_prefix_extraction(rest: &str, prefix: &str, line: &str, start_positions: Vec<usize>) -> HashMap<usize, String> {","highlight_start":48,"highlight_end":60}],"label":"","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/helper.rs","byte_start":4876,"byte_end":4886,"line_start":184,"line_end":184,"column_start":62,"column_end":72,"is_primary":false,"text":[{"text":"pub fn check_str_prefix_extraction(rest: &str, prefix: &str, line: &str, start_positions: Vec<usize>) -> HashMap<usize, String> {","highlight_start":62,"highlight_end":72}],"label":"","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/helper.rs","byte_start":4888,"byte_end":4915,"line_start":184,"line_end":184,"column_start":74,"column_end":101,"is_primary":false,"text":[{"text":"pub fn check_str_prefix_extraction(rest: &str, prefix: &str, line: &str, start_positions: Vec<usize>) -> HashMap<usize, String> {","highlight_start":74,"highlight_end":101}],"label":"","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/helper.rs","byte_start":4822,"byte_end":4849,"line_start":184,"line_end":184,"column_start":8,"column_end":35,"is_primary":true,"text":[{"text":"pub fn check_str_prefix_extraction(rest: &str, prefix: &str, line: &str, start_positions: Vec<usize>) -> HashMap<usize, String> {","highlight_start":8,"highlight_end":35}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"provide the arguments","code":null,"level":"help","spans":[{"file_name":"src/helper.rs","byte_start":11056,"byte_end":11069,"line_start":353,"line_end":353,"column_start":54,"column_end":67,"is_primary":true,"text":[{"text":"        let output_strs = check_str_prefix_extraction(regex, line);","highlight_start":54,"highlight_end":67}],"label":null,"suggested_replacement":"(regex, line, /* &str */, /* Vec<usize> */)","suggestion_applicability":"HasPlaceholders","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0061]\u001b[0m\u001b[0m\u001b[1m: this function takes 4 arguments but 2 arguments were supplied\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/helper.rs:353:27\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m353\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m        let output_strs = check_str_prefix_extraction(regex, line);\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                          \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m-------------\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12mtwo arguments of type `&str` and `Vec<usize>` are missing\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;10mnote\u001b[0m\u001b[0m: function defined here\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/helper.rs:184:8\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m184\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0mpub fn check_str_prefix_extraction(rest: &str, prefix: &str, line: &str, start_positions: Vec<usize>) -> HashMap<usize, String> {\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m       \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m----------\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m------------\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m----------\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m---------------------------\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14mhelp\u001b[0m\u001b[0m: provide the arguments\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m353\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m        let output_strs = check_str_prefix_extraction\u001b[0m\u001b[0m\u001b[38;5;10m(regex, line, /* &str */, /* Vec<usize> */)\u001b[0m\u001b[0m;\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                                                      \u001b[0m\u001b[0m\u001b[38;5;10m~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"this function takes 4 arguments but 2 arguments were supplied","code":{"code":"E0061","explanation":"An invalid number of arguments was passed when calling a function.\n\nErroneous code example:\n\n```compile_fail,E0061\nfn f(u: i32) {}\n\nf(); // error!\n```\n\nThe number of arguments passed to a function must match the number of arguments\nspecified in the function signature.\n\nFor example, a function like:\n\n```\nfn f(a: u16, b: &str) {}\n```\n\nMust always be called with exactly two arguments, e.g., `f(2, \"test\")`.\n\nNote that Rust does not have a notion of optional function arguments or\nvariadic functions (except for its C-FFI).\n"},"level":"error","spans":[{"file_name":"src/helper.rs","byte_start":11815,"byte_end":11829,"line_start":373,"line_end":373,"column_start":54,"column_end":68,"is_primary":false,"text":[{"text":"        let output_strs = check_str_prefix_extraction(&regex, line);","highlight_start":54,"highlight_end":68}],"label":"two arguments of type `&str` and `Vec<usize>` are missing","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/helper.rs","byte_start":11788,"byte_end":11815,"line_start":373,"line_end":373,"column_start":27,"column_end":54,"is_primary":true,"text":[{"text":"        let output_strs = check_str_prefix_extraction(&regex, line);","highlight_start":27,"highlight_end":54}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"function defined here","code":null,"level":"note","spans":[{"file_name":"src/helper.rs","byte_start":4850,"byte_end":4860,"line_start":184,"line_end":184,"column_start":36,"column_end":46,"is_primary":false,"text":[{"text":"pub fn check_str_prefix_extraction(rest: &str, prefix: &str, line: &str, start_positions: Vec<usize>) -> HashMap<usize, String> {","highlight_start":36,"highlight_end":46}],"label":"","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/helper.rs","byte_start":4862,"byte_end":4874,"line_start":184,"line_end":184,"column_start":48,"column_end":60,"is_primary":false,"text":[{"text":"pub fn check_str_prefix_extraction(rest: &str, prefix: &str, line: &str, start_positions: Vec<usize>) -> HashMap<usize, String> {","highlight_start":48,"highlight_end":60}],"label":"","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/helper.rs","byte_start":4876,"byte_end":4886,"line_start":184,"line_end":184,"column_start":62,"column_end":72,"is_primary":false,"text":[{"text":"pub fn check_str_prefix_extraction(rest: &str, prefix: &str, line: &str, start_positions: Vec<usize>) -> HashMap<usize, String> {","highlight_start":62,"highlight_end":72}],"label":"","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/helper.rs","byte_start":4888,"byte_end":4915,"line_start":184,"line_end":184,"column_start":74,"column_end":101,"is_primary":false,"text":[{"text":"pub fn check_str_prefix_extraction(rest: &str, prefix: &str, line: &str, start_positions: Vec<usize>) -> HashMap<usize, String> {","highlight_start":74,"highlight_end":101}],"label":"","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/helper.rs","byte_start":4822,"byte_end":4849,"line_start":184,"line_end":184,"column_start":8,"column_end":35,"is_primary":true,"text":[{"text":"pub fn check_str_prefix_extraction(rest: &str, prefix: &str, line: &str, start_positions: Vec<usize>) -> HashMap<usize, String> {","highlight_start":8,"highlight_end":35}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"provide the arguments","code":null,"level":"help","spans":[{"file_name":"src/helper.rs","byte_start":11815,"byte_end":11829,"line_start":373,"line_end":373,"column_start":54,"column_end":68,"is_primary":true,"text":[{"text":"        let output_strs = check_str_prefix_extraction(&regex, line);","highlight_start":54,"highlight_end":68}],"label":null,"suggested_replacement":"(&regex, line, /* &str */, /* Vec<usize> */)","suggestion_applicability":"HasPlaceholders","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0061]\u001b[0m\u001b[0m\u001b[1m: this function takes 4 arguments but 2 arguments were supplied\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/helper.rs:373:27\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m373\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m        let output_strs = check_str_prefix_extraction(&regex, line);\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                          \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--------------\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12mtwo arguments of type `&str` and `Vec<usize>` are missing\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;10mnote\u001b[0m\u001b[0m: function defined here\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/helper.rs:184:8\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m184\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0mpub fn check_str_prefix_extraction(rest: &str, prefix: &str, line: &str, start_positions: Vec<usize>) -> HashMap<usize, String> {\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m       \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m----------\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m------------\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m----------\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m---------------------------\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14mhelp\u001b[0m\u001b[0m: provide the arguments\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m373\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m        let output_strs = check_str_prefix_extraction\u001b[0m\u001b[0m\u001b[38;5;10m(&regex, line, /* &str */, /* Vec<usize> */)\u001b[0m\u001b[0m;\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                                                      \u001b[0m\u001b[0m\u001b[38;5;10m~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"this function takes 4 arguments but 2 arguments were supplied","code":{"code":"E0061","explanation":"An invalid number of arguments was passed when calling a function.\n\nErroneous code example:\n\n```compile_fail,E0061\nfn f(u: i32) {}\n\nf(); // error!\n```\n\nThe number of arguments passed to a function must match the number of arguments\nspecified in the function signature.\n\nFor example, a function like:\n\n```\nfn f(a: u16, b: &str) {}\n```\n\nMust always be called with exactly two arguments, e.g., `f(2, \"test\")`.\n\nNote that Rust does not have a notion of optional function arguments or\nvariadic functions (except for its C-FFI).\n"},"level":"error","spans":[{"file_name":"src/helper.rs","byte_start":12579,"byte_end":12593,"line_start":393,"line_end":393,"column_start":54,"column_end":68,"is_primary":false,"text":[{"text":"        let output_strs = check_str_prefix_extraction(&regex, line);","highlight_start":54,"highlight_end":68}],"label":"two arguments of type `&str` and `Vec<usize>` are missing","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/helper.rs","byte_start":12552,"byte_end":12579,"line_start":393,"line_end":393,"column_start":27,"column_end":54,"is_primary":true,"text":[{"text":"        let output_strs = check_str_prefix_extraction(&regex, line);","highlight_start":27,"highlight_end":54}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"function defined here","code":null,"level":"note","spans":[{"file_name":"src/helper.rs","byte_start":4850,"byte_end":4860,"line_start":184,"line_end":184,"column_start":36,"column_end":46,"is_primary":false,"text":[{"text":"pub fn check_str_prefix_extraction(rest: &str, prefix: &str, line: &str, start_positions: Vec<usize>) -> HashMap<usize, String> {","highlight_start":36,"highlight_end":46}],"label":"","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/helper.rs","byte_start":4862,"byte_end":4874,"line_start":184,"line_end":184,"column_start":48,"column_end":60,"is_primary":false,"text":[{"text":"pub fn check_str_prefix_extraction(rest: &str, prefix: &str, line: &str, start_positions: Vec<usize>) -> HashMap<usize, String> {","highlight_start":48,"highlight_end":60}],"label":"","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/helper.rs","byte_start":4876,"byte_end":4886,"line_start":184,"line_end":184,"column_start":62,"column_end":72,"is_primary":false,"text":[{"text":"pub fn check_str_prefix_extraction(rest: &str, prefix: &str, line: &str, start_positions: Vec<usize>) -> HashMap<usize, String> {","highlight_start":62,"highlight_end":72}],"label":"","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/helper.rs","byte_start":4888,"byte_end":4915,"line_start":184,"line_end":184,"column_start":74,"column_end":101,"is_primary":false,"text":[{"text":"pub fn check_str_prefix_extraction(rest: &str, prefix: &str, line: &str, start_positions: Vec<usize>) -> HashMap<usize, String> {","highlight_start":74,"highlight_end":101}],"label":"","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/helper.rs","byte_start":4822,"byte_end":4849,"line_start":184,"line_end":184,"column_start":8,"column_end":35,"is_primary":true,"text":[{"text":"pub fn check_str_prefix_extraction(rest: &str, prefix: &str, line: &str, start_positions: Vec<usize>) -> HashMap<usize, String> {","highlight_start":8,"highlight_end":35}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"provide the arguments","code":null,"level":"help","spans":[{"file_name":"src/helper.rs","byte_start":12579,"byte_end":12593,"line_start":393,"line_end":393,"column_start":54,"column_end":68,"is_primary":true,"text":[{"text":"        let output_strs = check_str_prefix_extraction(&regex, line);","highlight_start":54,"highlight_end":68}],"label":null,"suggested_replacement":"(&regex, line, /* &str */, /* Vec<usize> */)","suggestion_applicability":"HasPlaceholders","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0061]\u001b[0m\u001b[0m\u001b[1m: this function takes 4 arguments but 2 arguments were supplied\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/helper.rs:393:27\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m393\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m        let output_strs = check_str_prefix_extraction(&regex, line);\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                          \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--------------\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12mtwo arguments of type `&str` and `Vec<usize>` are missing\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;10mnote\u001b[0m\u001b[0m: function defined here\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/helper.rs:184:8\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m184\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0mpub fn check_str_prefix_extraction(rest: &str, prefix: &str, line: &str, start_positions: Vec<usize>) -> HashMap<usize, String> {\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m       \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m----------\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m------------\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m----------\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m---------------------------\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14mhelp\u001b[0m\u001b[0m: provide the arguments\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m393\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m        let output_strs = check_str_prefix_extraction\u001b[0m\u001b[0m\u001b[38;5;10m(&regex, line, /* &str */, /* Vec<usize> */)\u001b[0m\u001b[0m;\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                                                      \u001b[0m\u001b[0m\u001b[38;5;10m~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"this function takes 4 arguments but 2 arguments were supplied","code":{"code":"E0061","explanation":"An invalid number of arguments was passed when calling a function.\n\nErroneous code example:\n\n```compile_fail,E0061\nfn f(u: i32) {}\n\nf(); // error!\n```\n\nThe number of arguments passed to a function must match the number of arguments\nspecified in the function signature.\n\nFor example, a function like:\n\n```\nfn f(a: u16, b: &str) {}\n```\n\nMust always be called with exactly two arguments, e.g., `f(2, \"test\")`.\n\nNote that Rust does not have a notion of optional function arguments or\nvariadic functions (except for its C-FFI).\n"},"level":"error","spans":[{"file_name":"src/helper.rs","byte_start":13414,"byte_end":13428,"line_start":415,"line_end":415,"column_start":54,"column_end":68,"is_primary":false,"text":[{"text":"        let output_strs = check_str_prefix_extraction(&regex, line);","highlight_start":54,"highlight_end":68}],"label":"two arguments of type `&str` and `Vec<usize>` are missing","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/helper.rs","byte_start":13387,"byte_end":13414,"line_start":415,"line_end":415,"column_start":27,"column_end":54,"is_primary":true,"text":[{"text":"        let output_strs = check_str_prefix_extraction(&regex, line);","highlight_start":27,"highlight_end":54}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"function defined here","code":null,"level":"note","spans":[{"file_name":"src/helper.rs","byte_start":4850,"byte_end":4860,"line_start":184,"line_end":184,"column_start":36,"column_end":46,"is_primary":false,"text":[{"text":"pub fn check_str_prefix_extraction(rest: &str, prefix: &str, line: &str, start_positions: Vec<usize>) -> HashMap<usize, String> {","highlight_start":36,"highlight_end":46}],"label":"","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/helper.rs","byte_start":4862,"byte_end":4874,"line_start":184,"line_end":184,"column_start":48,"column_end":60,"is_primary":false,"text":[{"text":"pub fn check_str_prefix_extraction(rest: &str, prefix: &str, line: &str, start_positions: Vec<usize>) -> HashMap<usize, String> {","highlight_start":48,"highlight_end":60}],"label":"","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/helper.rs","byte_start":4876,"byte_end":4886,"line_start":184,"line_end":184,"column_start":62,"column_end":72,"is_primary":false,"text":[{"text":"pub fn check_str_prefix_extraction(rest: &str, prefix: &str, line: &str, start_positions: Vec<usize>) -> HashMap<usize, String> {","highlight_start":62,"highlight_end":72}],"label":"","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/helper.rs","byte_start":4888,"byte_end":4915,"line_start":184,"line_end":184,"column_start":74,"column_end":101,"is_primary":false,"text":[{"text":"pub fn check_str_prefix_extraction(rest: &str, prefix: &str, line: &str, start_positions: Vec<usize>) -> HashMap<usize, String> {","highlight_start":74,"highlight_end":101}],"label":"","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/helper.rs","byte_start":4822,"byte_end":4849,"line_start":184,"line_end":184,"column_start":8,"column_end":35,"is_primary":true,"text":[{"text":"pub fn check_str_prefix_extraction(rest: &str, prefix: &str, line: &str, start_positions: Vec<usize>) -> HashMap<usize, String> {","highlight_start":8,"highlight_end":35}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"provide the arguments","code":null,"level":"help","spans":[{"file_name":"src/helper.rs","byte_start":13414,"byte_end":13428,"line_start":415,"line_end":415,"column_start":54,"column_end":68,"is_primary":true,"text":[{"text":"        let output_strs = check_str_prefix_extraction(&regex, line);","highlight_start":54,"highlight_end":68}],"label":null,"suggested_replacement":"(&regex, line, /* &str */, /* Vec<usize> */)","suggestion_applicability":"HasPlaceholders","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0061]\u001b[0m\u001b[0m\u001b[1m: this function takes 4 arguments but 2 arguments were supplied\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/helper.rs:415:27\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m415\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m        let output_strs = check_str_prefix_extraction(&regex, line);\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                          \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--------------\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12mtwo arguments of type `&str` and `Vec<usize>` are missing\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;10mnote\u001b[0m\u001b[0m: function defined here\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/helper.rs:184:8\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m184\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0mpub fn check_str_prefix_extraction(rest: &str, prefix: &str, line: &str, start_positions: Vec<usize>) -> HashMap<usize, String> {\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m       \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m----------\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m------------\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m----------\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m---------------------------\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14mhelp\u001b[0m\u001b[0m: provide the arguments\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m415\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m        let output_strs = check_str_prefix_extraction\u001b[0m\u001b[0m\u001b[38;5;10m(&regex, line, /* &str */, /* Vec<usize> */)\u001b[0m\u001b[0m;\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                                                      \u001b[0m\u001b[0m\u001b[38;5;10m~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"this function takes 4 arguments but 2 arguments were supplied","code":{"code":"E0061","explanation":"An invalid number of arguments was passed when calling a function.\n\nErroneous code example:\n\n```compile_fail,E0061\nfn f(u: i32) {}\n\nf(); // error!\n```\n\nThe number of arguments passed to a function must match the number of arguments\nspecified in the function signature.\n\nFor example, a function like:\n\n```\nfn f(a: u16, b: &str) {}\n```\n\nMust always be called with exactly two arguments, e.g., `f(2, \"test\")`.\n\nNote that Rust does not have a notion of optional function arguments or\nvariadic functions (except for its C-FFI).\n"},"level":"error","spans":[{"file_name":"src/helper.rs","byte_start":17161,"byte_end":17175,"line_start":539,"line_end":539,"column_start":54,"column_end":68,"is_primary":false,"text":[{"text":"        let output_strs = check_str_prefix_extraction(&regex, line);","highlight_start":54,"highlight_end":68}],"label":"two arguments of type `&str` and `Vec<usize>` are missing","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/helper.rs","byte_start":17134,"byte_end":17161,"line_start":539,"line_end":539,"column_start":27,"column_end":54,"is_primary":true,"text":[{"text":"        let output_strs = check_str_prefix_extraction(&regex, line);","highlight_start":27,"highlight_end":54}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"function defined here","code":null,"level":"note","spans":[{"file_name":"src/helper.rs","byte_start":4850,"byte_end":4860,"line_start":184,"line_end":184,"column_start":36,"column_end":46,"is_primary":false,"text":[{"text":"pub fn check_str_prefix_extraction(rest: &str, prefix: &str, line: &str, start_positions: Vec<usize>) -> HashMap<usize, String> {","highlight_start":36,"highlight_end":46}],"label":"","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/helper.rs","byte_start":4862,"byte_end":4874,"line_start":184,"line_end":184,"column_start":48,"column_end":60,"is_primary":false,"text":[{"text":"pub fn check_str_prefix_extraction(rest: &str, prefix: &str, line: &str, start_positions: Vec<usize>) -> HashMap<usize, String> {","highlight_start":48,"highlight_end":60}],"label":"","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/helper.rs","byte_start":4876,"byte_end":4886,"line_start":184,"line_end":184,"column_start":62,"column_end":72,"is_primary":false,"text":[{"text":"pub fn check_str_prefix_extraction(rest: &str, prefix: &str, line: &str, start_positions: Vec<usize>) -> HashMap<usize, String> {","highlight_start":62,"highlight_end":72}],"label":"","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/helper.rs","byte_start":4888,"byte_end":4915,"line_start":184,"line_end":184,"column_start":74,"column_end":101,"is_primary":false,"text":[{"text":"pub fn check_str_prefix_extraction(rest: &str, prefix: &str, line: &str, start_positions: Vec<usize>) -> HashMap<usize, String> {","highlight_start":74,"highlight_end":101}],"label":"","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/helper.rs","byte_start":4822,"byte_end":4849,"line_start":184,"line_end":184,"column_start":8,"column_end":35,"is_primary":true,"text":[{"text":"pub fn check_str_prefix_extraction(rest: &str, prefix: &str, line: &str, start_positions: Vec<usize>) -> HashMap<usize, String> {","highlight_start":8,"highlight_end":35}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"provide the arguments","code":null,"level":"help","spans":[{"file_name":"src/helper.rs","byte_start":17161,"byte_end":17175,"line_start":539,"line_end":539,"column_start":54,"column_end":68,"is_primary":true,"text":[{"text":"        let output_strs = check_str_prefix_extraction(&regex, line);","highlight_start":54,"highlight_end":68}],"label":null,"suggested_replacement":"(&regex, line, /* &str */, /* Vec<usize> */)","suggestion_applicability":"HasPlaceholders","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0061]\u001b[0m\u001b[0m\u001b[1m: this function takes 4 arguments but 2 arguments were supplied\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/helper.rs:539:27\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m539\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m        let output_strs = check_str_prefix_extraction(&regex, line);\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                          \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--------------\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12mtwo arguments of type `&str` and `Vec<usize>` are missing\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;10mnote\u001b[0m\u001b[0m: function defined here\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/helper.rs:184:8\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m184\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0mpub fn check_str_prefix_extraction(rest: &str, prefix: &str, line: &str, start_positions: Vec<usize>) -> HashMap<usize, String> {\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m       \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m----------\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m------------\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m----------\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m---------------------------\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14mhelp\u001b[0m\u001b[0m: provide the arguments\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m539\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m        let output_strs = check_str_prefix_extraction\u001b[0m\u001b[0m\u001b[38;5;10m(&regex, line, /* &str */, /* Vec<usize> */)\u001b[0m\u001b[0m;\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                                                      \u001b[0m\u001b[0m\u001b[38;5;10m~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"this function takes 4 arguments but 2 arguments were supplied","code":{"code":"E0061","explanation":"An invalid number of arguments was passed when calling a function.\n\nErroneous code example:\n\n```compile_fail,E0061\nfn f(u: i32) {}\n\nf(); // error!\n```\n\nThe number of arguments passed to a function must match the number of arguments\nspecified in the function signature.\n\nFor example, a function like:\n\n```\nfn f(a: u16, b: &str) {}\n```\n\nMust always be called with exactly two arguments, e.g., `f(2, \"test\")`.\n\nNote that Rust does not have a notion of optional function arguments or\nvariadic functions (except for its C-FFI).\n"},"level":"error","spans":[{"file_name":"src/helper.rs","byte_start":17982,"byte_end":17996,"line_start":560,"line_end":560,"column_start":54,"column_end":68,"is_primary":false,"text":[{"text":"        let output_strs = check_str_prefix_extraction(&regex, line);","highlight_start":54,"highlight_end":68}],"label":"two arguments of type `&str` and `Vec<usize>` are missing","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/helper.rs","byte_start":17955,"byte_end":17982,"line_start":560,"line_end":560,"column_start":27,"column_end":54,"is_primary":true,"text":[{"text":"        let output_strs = check_str_prefix_extraction(&regex, line);","highlight_start":27,"highlight_end":54}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"function defined here","code":null,"level":"note","spans":[{"file_name":"src/helper.rs","byte_start":4850,"byte_end":4860,"line_start":184,"line_end":184,"column_start":36,"column_end":46,"is_primary":false,"text":[{"text":"pub fn check_str_prefix_extraction(rest: &str, prefix: &str, line: &str, start_positions: Vec<usize>) -> HashMap<usize, String> {","highlight_start":36,"highlight_end":46}],"label":"","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/helper.rs","byte_start":4862,"byte_end":4874,"line_start":184,"line_end":184,"column_start":48,"column_end":60,"is_primary":false,"text":[{"text":"pub fn check_str_prefix_extraction(rest: &str, prefix: &str, line: &str, start_positions: Vec<usize>) -> HashMap<usize, String> {","highlight_start":48,"highlight_end":60}],"label":"","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/helper.rs","byte_start":4876,"byte_end":4886,"line_start":184,"line_end":184,"column_start":62,"column_end":72,"is_primary":false,"text":[{"text":"pub fn check_str_prefix_extraction(rest: &str, prefix: &str, line: &str, start_positions: Vec<usize>) -> HashMap<usize, String> {","highlight_start":62,"highlight_end":72}],"label":"","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/helper.rs","byte_start":4888,"byte_end":4915,"line_start":184,"line_end":184,"column_start":74,"column_end":101,"is_primary":false,"text":[{"text":"pub fn check_str_prefix_extraction(rest: &str, prefix: &str, line: &str, start_positions: Vec<usize>) -> HashMap<usize, String> {","highlight_start":74,"highlight_end":101}],"label":"","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/helper.rs","byte_start":4822,"byte_end":4849,"line_start":184,"line_end":184,"column_start":8,"column_end":35,"is_primary":true,"text":[{"text":"pub fn check_str_prefix_extraction(rest: &str, prefix: &str, line: &str, start_positions: Vec<usize>) -> HashMap<usize, String> {","highlight_start":8,"highlight_end":35}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"provide the arguments","code":null,"level":"help","spans":[{"file_name":"src/helper.rs","byte_start":17982,"byte_end":17996,"line_start":560,"line_end":560,"column_start":54,"column_end":68,"is_primary":true,"text":[{"text":"        let output_strs = check_str_prefix_extraction(&regex, line);","highlight_start":54,"highlight_end":68}],"label":null,"suggested_replacement":"(&regex, line, /* &str */, /* Vec<usize> */)","suggestion_applicability":"HasPlaceholders","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0061]\u001b[0m\u001b[0m\u001b[1m: this function takes 4 arguments but 2 arguments were supplied\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/helper.rs:560:27\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m560\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m        let output_strs = check_str_prefix_extraction(&regex, line);\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                          \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--------------\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12mtwo arguments of type `&str` and `Vec<usize>` are missing\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;10mnote\u001b[0m\u001b[0m: function defined here\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/helper.rs:184:8\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m184\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0mpub fn check_str_prefix_extraction(rest: &str, prefix: &str, line: &str, start_positions: Vec<usize>) -> HashMap<usize, String> {\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m       \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m----------\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m------------\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m----------\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m---------------------------\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14mhelp\u001b[0m\u001b[0m: provide the arguments\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m560\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m        let output_strs = check_str_prefix_extraction\u001b[0m\u001b[0m\u001b[38;5;10m(&regex, line, /* &str */, /* Vec<usize> */)\u001b[0m\u001b[0m;\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                                                      \u001b[0m\u001b[0m\u001b[38;5;10m~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"this function takes 4 arguments but 2 arguments were supplied","code":{"code":"E0061","explanation":"An invalid number of arguments was passed when calling a function.\n\nErroneous code example:\n\n```compile_fail,E0061\nfn f(u: i32) {}\n\nf(); // error!\n```\n\nThe number of arguments passed to a function must match the number of arguments\nspecified in the function signature.\n\nFor example, a function like:\n\n```\nfn f(a: u16, b: &str) {}\n```\n\nMust always be called with exactly two arguments, e.g., `f(2, \"test\")`.\n\nNote that Rust does not have a notion of optional function arguments or\nvariadic functions (except for its C-FFI).\n"},"level":"error","spans":[{"file_name":"src/helper.rs","byte_start":19326,"byte_end":19340,"line_start":596,"line_end":596,"column_start":54,"column_end":68,"is_primary":false,"text":[{"text":"        let output_strs = check_str_prefix_extraction(&regex, line);","highlight_start":54,"highlight_end":68}],"label":"two arguments of type `&str` and `Vec<usize>` are missing","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/helper.rs","byte_start":19299,"byte_end":19326,"line_start":596,"line_end":596,"column_start":27,"column_end":54,"is_primary":true,"text":[{"text":"        let output_strs = check_str_prefix_extraction(&regex, line);","highlight_start":27,"highlight_end":54}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"function defined here","code":null,"level":"note","spans":[{"file_name":"src/helper.rs","byte_start":4850,"byte_end":4860,"line_start":184,"line_end":184,"column_start":36,"column_end":46,"is_primary":false,"text":[{"text":"pub fn check_str_prefix_extraction(rest: &str, prefix: &str, line: &str, start_positions: Vec<usize>) -> HashMap<usize, String> {","highlight_start":36,"highlight_end":46}],"label":"","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/helper.rs","byte_start":4862,"byte_end":4874,"line_start":184,"line_end":184,"column_start":48,"column_end":60,"is_primary":false,"text":[{"text":"pub fn check_str_prefix_extraction(rest: &str, prefix: &str, line: &str, start_positions: Vec<usize>) -> HashMap<usize, String> {","highlight_start":48,"highlight_end":60}],"label":"","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/helper.rs","byte_start":4876,"byte_end":4886,"line_start":184,"line_end":184,"column_start":62,"column_end":72,"is_primary":false,"text":[{"text":"pub fn check_str_prefix_extraction(rest: &str, prefix: &str, line: &str, start_positions: Vec<usize>) -> HashMap<usize, String> {","highlight_start":62,"highlight_end":72}],"label":"","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/helper.rs","byte_start":4888,"byte_end":4915,"line_start":184,"line_end":184,"column_start":74,"column_end":101,"is_primary":false,"text":[{"text":"pub fn check_str_prefix_extraction(rest: &str, prefix: &str, line: &str, start_positions: Vec<usize>) -> HashMap<usize, String> {","highlight_start":74,"highlight_end":101}],"label":"","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/helper.rs","byte_start":4822,"byte_end":4849,"line_start":184,"line_end":184,"column_start":8,"column_end":35,"is_primary":true,"text":[{"text":"pub fn check_str_prefix_extraction(rest: &str, prefix: &str, line: &str, start_positions: Vec<usize>) -> HashMap<usize, String> {","highlight_start":8,"highlight_end":35}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"provide the arguments","code":null,"level":"help","spans":[{"file_name":"src/helper.rs","byte_start":19326,"byte_end":19340,"line_start":596,"line_end":596,"column_start":54,"column_end":68,"is_primary":true,"text":[{"text":"        let output_strs = check_str_prefix_extraction(&regex, line);","highlight_start":54,"highlight_end":68}],"label":null,"suggested_replacement":"(&regex, line, /* &str */, /* Vec<usize> */)","suggestion_applicability":"HasPlaceholders","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0061]\u001b[0m\u001b[0m\u001b[1m: this function takes 4 arguments but 2 arguments were supplied\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/helper.rs:596:27\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m596\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m        let output_strs = check_str_prefix_extraction(&regex, line);\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                          \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--------------\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12mtwo arguments of type `&str` and `Vec<usize>` are missing\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;10mnote\u001b[0m\u001b[0m: function defined here\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/helper.rs:184:8\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m184\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0mpub fn check_str_prefix_extraction(rest: &str, prefix: &str, line: &str, start_positions: Vec<usize>) -> HashMap<usize, String> {\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m       \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m----------\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m------------\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m----------\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m---------------------------\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14mhelp\u001b[0m\u001b[0m: provide the arguments\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m596\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m        let output_strs = check_str_prefix_extraction\u001b[0m\u001b[0m\u001b[38;5;10m(&regex, line, /* &str */, /* Vec<usize> */)\u001b[0m\u001b[0m;\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                                                      \u001b[0m\u001b[0m\u001b[38;5;10m~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"this function takes 4 arguments but 2 arguments were supplied","code":{"code":"E0061","explanation":"An invalid number of arguments was passed when calling a function.\n\nErroneous code example:\n\n```compile_fail,E0061\nfn f(u: i32) {}\n\nf(); // error!\n```\n\nThe number of arguments passed to a function must match the number of arguments\nspecified in the function signature.\n\nFor example, a function like:\n\n```\nfn f(a: u16, b: &str) {}\n```\n\nMust always be called with exactly two arguments, e.g., `f(2, \"test\")`.\n\nNote that Rust does not have a notion of optional function arguments or\nvariadic functions (except for its C-FFI).\n"},"level":"error","spans":[{"file_name":"src/helper.rs","byte_start":20667,"byte_end":20681,"line_start":632,"line_end":632,"column_start":54,"column_end":68,"is_primary":false,"text":[{"text":"        let output_strs = check_str_prefix_extraction(&regex, line);","highlight_start":54,"highlight_end":68}],"label":"two arguments of type `&str` and `Vec<usize>` are missing","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/helper.rs","byte_start":20640,"byte_end":20667,"line_start":632,"line_end":632,"column_start":27,"column_end":54,"is_primary":true,"text":[{"text":"        let output_strs = check_str_prefix_extraction(&regex, line);","highlight_start":27,"highlight_end":54}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"function defined here","code":null,"level":"note","spans":[{"file_name":"src/helper.rs","byte_start":4850,"byte_end":4860,"line_start":184,"line_end":184,"column_start":36,"column_end":46,"is_primary":false,"text":[{"text":"pub fn check_str_prefix_extraction(rest: &str, prefix: &str, line: &str, start_positions: Vec<usize>) -> HashMap<usize, String> {","highlight_start":36,"highlight_end":46}],"label":"","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/helper.rs","byte_start":4862,"byte_end":4874,"line_start":184,"line_end":184,"column_start":48,"column_end":60,"is_primary":false,"text":[{"text":"pub fn check_str_prefix_extraction(rest: &str, prefix: &str, line: &str, start_positions: Vec<usize>) -> HashMap<usize, String> {","highlight_start":48,"highlight_end":60}],"label":"","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/helper.rs","byte_start":4876,"byte_end":4886,"line_start":184,"line_end":184,"column_start":62,"column_end":72,"is_primary":false,"text":[{"text":"pub fn check_str_prefix_extraction(rest: &str, prefix: &str, line: &str, start_positions: Vec<usize>) -> HashMap<usize, String> {","highlight_start":62,"highlight_end":72}],"label":"","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/helper.rs","byte_start":4888,"byte_end":4915,"line_start":184,"line_end":184,"column_start":74,"column_end":101,"is_primary":false,"text":[{"text":"pub fn check_str_prefix_extraction(rest: &str, prefix: &str, line: &str, start_positions: Vec<usize>) -> HashMap<usize, String> {","highlight_start":74,"highlight_end":101}],"label":"","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/helper.rs","byte_start":4822,"byte_end":4849,"line_start":184,"line_end":184,"column_start":8,"column_end":35,"is_primary":true,"text":[{"text":"pub fn check_str_prefix_extraction(rest: &str, prefix: &str, line: &str, start_positions: Vec<usize>) -> HashMap<usize, String> {","highlight_start":8,"highlight_end":35}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"provide the arguments","code":null,"level":"help","spans":[{"file_name":"src/helper.rs","byte_start":20667,"byte_end":20681,"line_start":632,"line_end":632,"column_start":54,"column_end":68,"is_primary":true,"text":[{"text":"        let output_strs = check_str_prefix_extraction(&regex, line);","highlight_start":54,"highlight_end":68}],"label":null,"suggested_replacement":"(&regex, line, /* &str */, /* Vec<usize> */)","suggestion_applicability":"HasPlaceholders","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0061]\u001b[0m\u001b[0m\u001b[1m: this function takes 4 arguments but 2 arguments were supplied\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/helper.rs:632:27\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m632\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m        let output_strs = check_str_prefix_extraction(&regex, line);\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                          \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--------------\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12mtwo arguments of type `&str` and `Vec<usize>` are missing\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;10mnote\u001b[0m\u001b[0m: function defined here\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/helper.rs:184:8\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m184\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0mpub fn check_str_prefix_extraction(rest: &str, prefix: &str, line: &str, start_positions: Vec<usize>) -> HashMap<usize, String> {\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m       \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m----------\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m------------\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m----------\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m---------------------------\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14mhelp\u001b[0m\u001b[0m: provide the arguments\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m632\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m        let output_strs = check_str_prefix_extraction\u001b[0m\u001b[0m\u001b[38;5;10m(&regex, line, /* &str */, /* Vec<usize> */)\u001b[0m\u001b[0m;\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                                                      \u001b[0m\u001b[0m\u001b[38;5;10m~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"aborting due to 9 previous errors; 12 warnings emitted","code":null,"level":"error","spans":[],"children":[],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror\u001b[0m\u001b[0m\u001b[1m: aborting due to 9 previous errors; 12 warnings emitted\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"For more information about this error, try `rustc --explain E0061`.","code":null,"level":"failure-note","spans":[],"children":[],"rendered":"\u001b[0m\u001b[1mFor more information about this error, try `rustc --explain E0061`.\u001b[0m\n"}
